\documentclass[oneside]{book}

\usepackage{../pyhelp} 
 
 
    
    \title{Python Guide\\Chapters 1-2, Basics of Python}
    
    \author{Daniel Scarbrough}
    \date{\today}
    
\makeindex

\begin{document}
\maketitle

\tableofcontents

\chapter{Introduction}

In Chapters 1 and 2, you will be introduced to the very basics of Python through a few examples. Each file in these examples is included in this repository and can be viewed, downloaded, copied, edited, etc. When first learning it can be helpful even to copy examples from scratch - meaning not using copy-paste - but typing it out line for line. Python is a language, and much like learning a spoken language this type of practice is helpful to start becoming fluent.

The examples here will follow the Text Editor + Terminal workflow in the Getting Started guide (Chapter 0). In most cases, Python code will be displayed in one block and the following block will show the terminal output of that code. Python code will be color-coded and terminal output will be all black text except for the terminal command to run the file: {\color{OliveGreen}\texttt{\$> python file.py}}. Some Python files and their outputs will be split between multiple listings, but the file name will always be mentioned explicitly.

If you are familiar with some other languages, you may notice that Python is not compiled. Instead Python is \textit{parsed}, meaning it is read and executed consecutively as the file is read. If what that means is unclear: don't fret. It will make sense as we dive deeper in further chapters. We will begin with the apparently mandatory beginner exercise: "Hello World".

\section{Hello World}
\label{sec:helloWorld}
As it is the unwritten law that all programming instruction begin with "Hello World!", we will implement it in Python to get started. This does have utility in demonstrating the simplicity of Python and the nature of it being a parsed language. Create a file named \texttt{helloWorld.py}, and all that we have to do is tell Python to print our greeting to the world with the one-liner in Listing \ref{code:helloWorld}.

\python{./code/chapter1/helloWorld.py}
       {Classic "Hello World!" code}
       {code:helloWorld}

Running the \texttt{helloWorld.py} program from a terminal will ask the Python parser to look at this file, and process the commands as they are read. Anything that is \textit{top level}, meaning anything not contained in a function, class, etc. will be executed as it is read and translated. This will yield the output in the terminal as we see in Listing \ref{shell:helloWorld}.

\shell{./code/chapter1/helloWorld.txt}
      {Running helloWorld.py from a shell}
      {shell:helloWorld}

\FloatBarrier

\chapter{Variables, Operations, and Basic Output}

\section{Variables, Operations, and Types}\label{sec:vars-types-ops}

\subsection{Variables}

Variables in Python are \textit{assigned} using the \index{operator!assignment =}\texttt{=} operator. The order of input is very important. The variable name, which can be any combination of letters, numbers, hyphens, and underscores - so long as the name begins with a letter. The case of the letters can be as you wish however be aware that Python variables are case sensitive, i.e. \texttt{m} and \texttt{M} are different variable names. When \textit{declaring} a variable (writing and assigning it a value for the first time), you do not need to specify what type of data it will hold. If you are familiar with a language like C, this will be quite different. Variables in Python are dynamic, so you can change them in just about any way you want. In listing \ref{code:varIntro}, we assign integers 6 and 3 to the variables \texttt{x} and \texttt{y}.

%

\usemintedstyle{autumn}
\begin{listing}[htb]
\begin{mdframed}[backgroundcolor=codebg]
\begin{minted}[linenos]{python}
x = 6
y = 3
\end{minted}
\end{mdframed}
\caption{Assigning values to the variables \texttt{x} and \texttt{y}.}
\label{code:varIntro}
\end{listing}

\subsubsection*{Style Notes: Variable Names}
When naming variables there are a few things to consider. Most important is to use names that are concise but still descriptive enough for you to easily understand your code and remember variables. This extends to code that may be shared; if someone else is working with your code and has to figure out what \texttt{var1} and \texttt{abcd} are for it will be very difficult. This doesn't mean that somewhat long names are always bad, but it is up to you to decide what works best for each case. For variables that have more than one word as part of the name there are a few styles that are common. The style that I will use throughout these documents and examples is \index{camelCase}\textbf{\texttt{camelCase}}. Camel case begins with a lower case letter and each new word has its first letter capitalized. Some examples are in Listing \ref{code:camelCase}.

\usemintedstyle{autumn}
\begin{listing}[htb]
\begin{mdframed}[backgroundcolor=codebg]
\begin{minted}[linenos]{python}
initVelocity = 6
spatialFrequency = 3
maxFreqX = 10
\end{minted}
\end{mdframed}
\caption{Assigning values to the variables with multi-word names using \texttt{camelCase.}}
\label{code:camelCase}
\end{listing}

Another common style is \index{snake\_case}\textbf{\texttt{snake\_case}}. This style uses an underscore between words. Which style you use is up to you (or your group or employer sometimes), but definitely don't just string words together in variable names without using a style that breaks apart words visually. Other style guidelines will be presented throughout these documents and examples. Example: constant variables that shouldn't be changed are often named in all capital letters. Maintaining a clean and readable style is essential in group work as well as solo coding so that you can read and modify your code again when you haven't looked at it in a while.

\FloatBarrier

\subsection{Basic Operations}
\label{sec:ops}
Now that you are familiar with the basis of starting a Python script and displaying output, it is time to cover the basic mathematical operations you can use in Python to do thing more interesting than printing out a nice message. These are all pretty self explanatory, but keep in mind that the syntax for exponents differs from some other programming languages:\index{operator}
\begin{itemize}
\item{\makebox[4cm][l]{Addition:} \texttt{+}}
\item{\makebox[4cm][l]{Subtraction:} \texttt{-}}
\item{\makebox[4cm][l]{Multiplication:} \texttt{*}}
\item{\makebox[4cm][l]{Division:} \texttt{/}}
\item{\makebox[4cm][l]{Exponent:} \texttt{**}}
\item{\makebox[4cm][l]{Modulus (remainder):} \texttt{\%}}
\item{\makebox[4cm][l]{Floor Division:} \texttt{//}}
\end{itemize}

Example usage of these operators is shown in Listings \ref{pyshell:opsIntroAddSub}-\ref{pyshell:opsIntroOther}. Everything is straightforward in these examples, but it is important to take note of when assignment (saving the result of an operation) occurs. When performing operations with variables, no changes to any variables occurs \textit{unless} a variable is explicitly changed with the \textit{assignment} operator \texttt{=}. This is seen in these example listings when assigning the results to \texttt{z}.

\pythonAndShellSub{./code/chapter2/section1/opsIntro.py}
{1}{11}
{./code/chapter2/section1/opsIntro.txt}
{1}{6}
{Lines 1-5 of \texttt{opsIntro.py} demonstrating variable assignment and using the \texttt{+} and \texttt{-} operators. It is important to note that the result of \texttt{x + y} within \texttt{print} is not stored. The result is printed and is not saved afterwards. \texttt{x} and \texttt{y} will still be \texttt{6} and \texttt{4} respectively. The output of this section is shown in the second frame.}{pyshell:opsIntroAddSub}\index{operator!addition +}\index{operator!subtraction -}

\pythonAndShellSub{./code/chapter2/section1/opsIntro.py}
{12}{19}
{./code/chapter2/section1/opsIntro.txt}
{7}{10}
{Lines 12-19 of \texttt{opsIntro.py} demonstrating use of the \texttt{*} and \texttt{/} operators. Note that in the output in the second frame, that after division the result is displayed with a decimal point. Since division may not always yield a whole integer, the \textit{type} is changed to \textit{float}. Types are discussed further in Section \ref{sec:dataTypes}.}
{pyshell:opsIntroMultDiv}\index{operator!multiplication *}\index{operator!division /}\index{type!float}

\pythonAndShellSub{./code/chapter2/section1/opsIntro.py}
{20}{25}
{./code/chapter2/section1/opsIntro.txt}
{11}{15}
{Lines 20-25 of \texttt{opsIntro.py} and its output. This section demonstrates that any further operations on \texttt{z} after division changed its type retains that type, even if the result is an integer.}
{pyshell:opsIntroRetainFloat}

\pythonAndShellSub{./code/chapter2/section1/opsIntro.py}
{26}{29}
{./code/chapter2/section1/opsIntro.txt}
{16}{19}
{Lines 26-29 of \texttt{opsIntro.py} and its output. This section provides an example of each of the common operators beyond simple arithmetic. Note that both the \texttt{\%} and \texttt{//} operators yield integer output.}
{pyshell:opsIntroOther}\index{operator!exponent **}\index{operator!modulus \%}\index{operator!floor division //}\index{operator!parentheses ()}

\FloatBarrier

\subsubsection*{Key Point - Operators}
\begin{itemize}
\item Variables don't change unless explicitly changed with the \texttt{=} assignment operator.
\item No operations are implied. A variable next to parentheses will cause an error unless the \texttt{*} operator is used (line 29 of Listing \ref{pyshell:opsIntroOther}).
\item Operations can change data types of variables (line 17 of Listing \ref{pyshell:opsIntroMultDiv} when using \texttt{/}). More on data types can be found in Section \ref{sec:dataTypes}.
\item Order of operations is as follows (first to last). Operators of the same group work from left to right in the code, except for \texttt{**} which reads from right to left.\index{operator!order of operations}
	\begin{itemize}
	\item[] \texttt{**}
	\item[] \texttt{*}, \texttt{/}, \texttt{//}, \texttt{\%}
	\item[] \texttt{+}, \texttt{-}
	\end{itemize}
\end{itemize}
Note that this operator list does not cover every Python operator. Further operators will be introduced in their applicable topics.

\subsection{Data Types}\label{sec:dataTypes}
Every variable in Python has a \index{type}\textit{type}. The type of a variable is key in terms of what can be done with it, and how it behaves differently from other types under the same circumstances. For example if I have a variable \texttt{x = "s"} and I say \texttt{x + 1}, it doesn't work. \texttt{"s"} isn't a number and we don't have a defined way to add a number to it. Type conversion is possible when needed (and when it makes sense to do so). First, here are the basic data types to get started with (name, keyword, examples):

\begin{itemize}
\item{\makebox[2cm][l]{Integer:} \makebox[2cm][l]{\texttt{int}} Ex: 1, 10, 121321, -982}\index{type!integer}
\item{\makebox[2cm][l]{Float:} \makebox[2cm][l]{\texttt{float}} Ex: 1.0, 10000.03, 12.687, -1.982}\index{type!float}
\item{\makebox[2cm][l]{Complex:} \makebox[2cm][l]{\texttt{complex}} Ex: 1 + 10j, 10.0 - 0.2j, 0.004j, -982 + 1.923j}\index{type!complex}
\item{\makebox[2cm][l]{String:} \makebox[2cm][l]{\texttt{str}} Ex: "words", "example words", "I miss Vine"}\index{type!string}
\item{\makebox[2cm][l]{Boolean:} \makebox[2cm][l]{\texttt{bool}} Ex: True, False (Capitalization is \textit{required}!)}\index{type!bool}
\end{itemize}

Note that for complex numbers only \texttt{j} will work and not \texttt{i}. Examples demonstrating how to work with complex numbers properly in Python will follow in later chapters. Type conversions can be achieved when needed by placing the variable within parentheses after the desired type. For example if a string contains only an integer, it can be converted to an integer type before performing a mathematical operation. An example shown in Listing \ref{code:typeCast}.\index{type!type cast}

\usemintedstyle{autumn}
\begin{listing}[htb]
\begin{mdframed}[backgroundcolor=codebg]
\begin{minted}[linenos]{python}
textVar = "100"
numVar = 80
result = numVar + int(textVar)
print(result)
\end{minted}
\end{mdframed}
\caption{Converting a \texttt{string} type variable to an \texttt{int} type for addition. The script prints 180 as the result. Note that if textVar were \texttt{"100.5"} or even \texttt{"100.0"} there would be an error as Python sees that it is a \texttt{float}.}
\label{code:typeCast}
\end{listing}

\FloatBarrier

\section{Printing Basics}\label{sec:printBasics}

In most cases in which you're running your program there will be some result that you'll be wanting to display. There are many forms to do so such as printing, plotting, output to a file, etc. We will start with the simplest - printing. We've already printed the classic greeting using \index{print}\texttt{print}, but there are a few more features beyond that single message available. The following breaks down the example file \texttt{printIntro.py} to exhibit these features. This is a good start, and our terminal output will be further extended in a later section about formatting.

\FloatBarrier

\subsection{First Features of \texttt{print} and Strings}\label{sec:printFeatures}

As we have seen in examples using \texttt{print}, every individual \texttt{print} statement is on its own line in the output. Do also consider that terminals don't always word-wrap, and that even if they do it often gets difficult to read. Keeping statements that fit within a standard sized terminal (usually about 80 characters) is good practice for usability, and multiple print statements is one way to achieve this, seen in the short demo of Listing \ref{pyshell:printIntro-multi}.

\pythonAndShellSub{./code/chapter2/section2/printIntro.py}
{1}{3}
{./code/chapter2/section2/printIntro.txt}
{1}{3}
{Lines 1-3 of \texttt{printIntro.py}. The call to run the script and the output of this section are shown in the second frame. Each print statement gets printed on its own line in the output.}
{pyshell:printIntro-multi}

\subsubsection{The \texttt{end} parameter}\label{sec:printEnd}

The first useful feature is the ability to set the ending for a print statement using a function \index{parameter!optional}\emph{parameter} (sometimes also called an \emph{argument}). This is done within the call to \texttt{print} (i.e. within its parentheses) by setting the \index{print!end}\texttt{end} parameter. This parameter is by default a special character that tells the terminal to move to the next line (like hitting the "enter" key in a text editor). Function parameters that have default values that can be manually changed are called \textit{optional parameters}. Setting the \texttt{end} parameter manually by using \mintinline{python}|end="..."| within \texttt{print} overrides this newline default, allowing for customization of output. This special newline\index{escape characters!newline $\backslash$n} character is discussed within this chapter in Section \ref{sec:escapeChars}. Looking at Listing \ref{pyshell:printIntro-end0}, it is shown that setting the \texttt{end} parameter to \texttt{""} leaves nothing as the ending, so the cursor that Python is using to output to the terminal stays where it is until the next print statement. Note that it is required to put the empty quotations \texttt{end=""} and doing something like \texttt{end=} will not work as the \texttt{=} operator will always operate on the next character - resulting in an error.

\pythonAndShellSub{./code/chapter2/section2/printIntro.py}
{2}{18}
{./code/chapter2/section2/printIntro.txt}
{3}{10}
{Lines 2-18 of \texttt{printIntro.py} and its output. Here the effects of changing the \texttt{end} optional argument are shown. Note that empty \texttt{print} statements here print a blank line in the output.}
{pyshell:printIntro-end0}

In some cases you may want to set the ending to something more interesting than nothing. This can be done by putting anything you'd like \textit{within} the quotes on the \texttt{end} parameter, as shown in Listing \ref{pyshell:printIntro-end0}. As you read through the example code, notice the inconvenient use of two empty \texttt{print} statements on lines 15 and 16 of Listing \ref{pyshell:printIntro-end0}. A good rule of thumb is if portions of code feel repetitive to write: there is likely a better way to write it. We'll see a better solution than these two empty \texttt{print}s shortly in Section \ref{sec:escapeChars}.

\subsubsection{Multiple Strings in \texttt{print}}\label{sec:printMulti}

Multiple strings (or variables) can be used in a \texttt{print} by separating them by a comma, allowing for a theoretically infinite number of statements input into one \texttt{print} - though more than a few becomes impractical. When using \index{type!string}\texttt{string}s as we are, you can also do what's called \index{concatenation}\emph{concatenation} - or combining two strings into one longer string. This can be done either with a juxtaposition of the two strings in quotes, or by using the \texttt{+} operator between them. Using \texttt{+} is usually easier to spot and read on the development side, so that method is recommended. All of this is shown in Listing \ref{pyshell:printIntro-concat}.

\pythonAndShellSub{./code/chapter2/section2/printIntro.py}
{18}{24}
{./code/chapter2/section2/printIntro.txt}
{10}{15}
{Lines 18-24 of \texttt{printIntro.py} and its output. This shows various methods of \textit{concatenation} with strings. Note that with variables of other types we can only use the comma separator - \texttt{print} then handles the conversion to the \texttt{string} type.}
{pyshell:printIntro-concat}

\subsubsection{The \texttt{sep} parameter}\label{sec:printSep}

The other major feature for \texttt{print} customization is the \index{print!sep}\texttt{sep} parameter. Setting this parameter will change what is automatically printed between comma separated values, which is by default a space: \texttt{sep=" "}. This can be adjusted to anything including empty quotes \texttt{sep=""} or a variable which we saw in Section \ref{sec:vars-types-ops}. A short example is shown in Listing \ref{pyshell:printIntro-sep}.

\pythonAndShellSub{./code/chapter2/section2/printIntro.py}
{24}{28}
{./code/chapter2/section2/printIntro.txt}
{15}{18}
{Lines 18-24 of \texttt{printIntro.py} and its output. This section demonstrates changing the \texttt{sep} optional argument. Note that this parameter only changes output between comma separated values in \texttt{print}.}
{pyshell:printIntro-sep}

Lastly for the \texttt{printIntro.py} example, we address an issue regarding quotes. Strings can be defined either with single quotes: \mintinline{python}{'this is a string'} or double quotes \mintinline{python}{"this is also a string"}. Which one to use is a matter of preference, but it is important to note that if you're using one then you can only use the other within the string. An example of this is shown in Listing \ref{pyshell:printIntro-quotes}, but a workaround is addressed in the following Section.
        
\pythonAndShellSub{./code/chapter2/section2/printIntro.py}
{28}{35}
{./code/chapter2/section2/printIntro.txt}
{18}{21}
{Lines 28-30 of \texttt{printIntro.py} and its output. This section demonstrates that \texttt{string}s can be defined with either double or single quotes, and that determines which can be used within the string. A solution to this issue follows in the next subsection.}
{pyshell:printIntro-quotes}

\FloatBarrier

\subsubsection*{Key Points - Printing Basics}
\begin{itemize}\index{print}
    \item Each default call to \texttt{print} will print the input on one line
    \item \texttt{print} has a few optional parameters: 
    \begin{itemize}
        \item \texttt{end} sets the string printed after printing the input(s)\\-default: new line
        \item \texttt{sep} sets the string printed between comma separated inputs\\-default: space
    \end{itemize}
    \item Multiple strings (or variables) can be printed in one \texttt{print} statement. 
\end{itemize}

\section{Escape Characters}\label{sec:escapeChars}

As you may have noticed in portions of \ref{sec:printBasics}, some code was repetitive. Using \texttt{sep} and \texttt{end} add helpful features but still leave \texttt{print} feeling a little stiff in its usage. This is where \index{escape characters}escape characters come in. These are special characters that you may know as "invisible characters" in a word processor, as well as a way to "escape" out of the function that some characters normally have in the Python language. Look at how we can make use of quotes within a string defined by quotes in Listing \ref{pyshell:escapeChars-intro}; this is a solution to the problem we saw in Listing \ref{pyshell:printIntro-quotes}.
 
\pythonAndShellSub{./code/chapter2/section2/printIntroEscapes.py}
{1}{4}
{./code/chapter2/section2/printIntroEscapes.txt}
{1}{4}
{Lines 1-4 of \texttt{printIntroEscapes.py} and its output. In this section, the backslash is used to "escape" the usage of quotes. This allows them to be printed without breaking the quotes used to define the \texttt{string}.}
{pyshell:escapeChars-intro}\index{escape characters!quotes $\backslash$""" $\backslash$'}

Escape characters can be used in any string, even those that you are not using immediately in a \texttt{print}. When they are in a \texttt{print} though, a new line escape \texttt{$\backslash$n} can be used - saving you from writing an empty print statement to write blank lines. The use of this new line special character is shown in Listing \ref{pyshell:escapeChars-newline}. One thing to be careful of here is typing in an extra space. If you were to type \mintinline{python}|end="\n "|,\index{print!end} then at the beginning of your new line, there would be a space as well.
    
\pythonAndShellSub{./code/chapter2/section2/printIntroEscapes.py}
{4}{11}
{./code/chapter2/section2/printIntroEscapes.txt}
{4}{12}
{Lines 4-11 of \texttt{printIntroEscapes.py} and its output. This section demonstrates the usage of the newline character \texttt{$\backslash$n}, and that the backslash only applies to the adjacent character.}
{pyshell:escapeChars-newline}\index{escape characters!newline $\backslash$n}

As just mentioned, escape characters can be in \emph{any} string, this includes the strings put into the \texttt{end} and \texttt{sep} parameters. This adds another degree of customization and flexibility. Basic examples are in Listings \ref{pyshell:escapeChars-printPars}.
    
\pythonAndShellSub{./code/chapter2/section2/printIntroEscapes.py}
{11}{17}
{./code/chapter2/section2/printIntroEscapes.txt}
{13}{18}
{Lines 11-17 of \texttt{printIntroEscapes.py} and its output. The adjustment of optional parameters \texttt{end} and \texttt{sep} with escape characters is demonstrated here.}
{pyshell:escapeChars-printPars}\index{print!end}\index{print!sep}\index{escape characters!tab $\backslash$t}

To summarize escape characters, the most commonly used ones are new line, tab, backslash, single quote, and double quote. These are mentioned in \texttt{print}s in Listing \ref{pyshell:escapeChars-common}. This example does not encompass all escape characters - further ones are typically in more advanced applications but a curious beginner can find many examples in a web search.
    
\pythonAndShellSub{./code/chapter2/section2/printIntroEscapes.py}
{17}{23}
{./code/chapter2/section2/printIntroEscapes.txt}
{18}{22}
{The final lines of \texttt{printIntroEscapes.py} and its output, summarizing the most often used escape characters. Note that to print a backslash, it needs to be escaped: $\backslash\backslash$.}
{pyshell:escapeChars-common}\index{escape characters!backslash $\backslash${$\backslash$}}

\FloatBarrier

\subsubsection*{Key Points - Escape Characters}
\begin{itemize}
    \item Escape characters are special characters that can be in strings
    \item These characters are "escaped" using the backslash \texttt{$\backslash$}
    \item Common escape characters:
    \begin{itemize}
        \item New line: \texttt{$\backslash$n}
        \item Tab: \texttt{$\backslash$t}
        \item Backslash: \texttt{$\backslash\backslash$}
        \item Single quote: \texttt{$\backslash$'}
        \item Double quote: \texttt{$\backslash$"}
    \end{itemize}
\end{itemize}\index{escape characters}


\section{Full Code Listings}

\subsection*{Chapter 1}
\pythonH{./code/chapter1/helloWorld.py}{The full content of \texttt{helloWorld.py} used in Section \ref{sec:helloWorld}}{fullpy:helloWorld}

\shellH{./code/chapter1/helloWorld.txt}{The full output of \texttt{helloWorld.py}}{fullshell:helloWorld}

\FloatBarrier

\subsection*{Chapter 2}
\pythonH{./code/chapter2/section1/opsIntro.py}{The full content of \texttt{opsIntro.py} used in Section \ref{sec:ops}}{fullpy:opsIntro}

\shellH{./code/chapter2/section1/opsIntro.txt}{The full output of \texttt{opsIntro.py}}{fullshell:opsIntro}

\pythonH{./code/chapter2/section2/printIntro.py}{The full content of \texttt{printIntro.py} used in Section \ref{sec:printBasics}}{fullpy:printIntro}

\shellH{./code/chapter2/section2/printIntro.txt}{The full output of \texttt{printIntro.py}}{fullshell:printIntro}

\pythonH{./code/chapter2/section2/printIntroEscapes.py}{The full content of \texttt{printIntroEscapes.py} used in Section \ref{sec:escapeChars}}{fullpy:printIntroEscapes}

\shellH{./code/chapter2/section2/printIntroEscapes.txt}{The full output of \texttt{printIntroEscapes.py}}{fullshell:printIntroEscapes}

\printindex

\end{document}